"""UFO export for RoboFog. RoboFab can't run in RoboFog because the python used by Fogis too old. However, there is an awful lot of data in Fog files that needs to get out there.The UFO support in Fog only needs to go one way, out.The glif files and plist files are saved in macroman encoding as it is the only thing thatthe 1.5.2 python in RobFog can make. The GlifLib reader does not seem to be bothered by this.This code needs to be able to execute in Python 1.5.2. Also: the support of GLIF in RoboFogonly needs to go one way. So there is no need to implement a draw method in Fog glyphs orbuild pens or the like. As long as the data gets out of RoboFog."""__version__ = 1.1import string, os, timefrom FogPlistWriter import writePlistfrom FogGlifWriter import FogGlifWriterfrom FogUnicode import fogGlyphNameToUnicodefrom types import DictType# from FogConstantsitem_open		= 20item_closed	 	= 21item_pict	   	= 22item_comp	   	= 23pt_corner		= 1pt_tangent	  	= 2pt_curve		= 3pt_bcp			= 4	# This is an illegal type to use, but Fog uses it internally for BCPspt_quadratic		= 5pt_virtualquad	= 7	# Used for virtual on-curve points when reading unpaired non-FogQ TTFogUFOExportTag = "org.robofog.ufoExport"def filterIllegals(text):	if text is None:		return None	new = ''	for c in text:		if ord(c) < 32:			continue		new = new + c	return new	try:	Falseexcept NameError:	False = 0	True = 1		class FogUFOWriter:	"""Write a UFO for a RoboFog font.	fogFont is a RoboFog font object	dst is the destination directory (the UFO)	renameGlyphs uses the 'AGLname' entry in glyph.lib as the glyph name (if present)	renameDict takes an optional dictionary for robofog glyphName to wanted glyphName mapping.		- names defined in the lib take precedence over the names in the rename dict.	flattenLib = 1 if you want to flatten the lib into UFO standard keynames (as RoboFab does it)	flattenLib = 0 if you want to store the lib as a nested set of dicts (as RoboFog does it)	correctPath does a correct path direction before exporting the glyph	addReportToLib adds a conversion report to the lib	saveBackground saves the background glyphs as well #glyphname.glif	interpretAnchors = 1 interprets single points (open paths!) as anchors, all will be named "anchor"	"""	def __init__(self, fogFont, dst, 			renameGlyphs=1, 			flattenLib=1, 			correctPath=0, 			addReportToLib=1, 			saveBackground=1,			exportLibs = 1,			printerFunc = None,			interpretAnchors = False,			renameDict = None			):		self.printerFunc = printerFunc		self.log('FogUFOExportLib version'+ `__version__`)		self.dst = dst		self._exportLibs = exportLibs		self._flattenLib = flattenLib		self._correctPath = correctPath		self._addReportToLib = addReportToLib		self._renameGlyphs = renameGlyphs		self._fontLib = fogFont.lib		self._saveBackground = saveBackground		self._renameTable = {}		self.isQuadFont = fogFont.curvetype == 11		self.contents = {}	# dict of glifname -> glif Filename		self._interpretAnchors = interpretAnchors		self._renameDict = renameDict		if self._addReportToLib:			self._addReport("date", `time.asctime(time.localtime(time.time()))`)			path = fogFont.path			self._addReport("sourcePath", path)		if not os.path.exists(self.dst):			os.makedirs(self.dst)		self.font = fogFont		self._makeRenameTable()				if len(fogFont)>0:			self.writeGlifs()		if len(fogFont.kerning.keys())>0:			self.writeKerning()		self.writeFontInfo()		self.writeMetaInfo()		if self._exportLibs:			if len(self._fontLib.keys())>0:				self.writeLib()		def log(self, text):		if self.printerFunc is not None:			self.printerFunc(text)		else:			print text					def _makeRenameTable(self):		"""Make a dict with glyph rename values		Checks these locations in the lib for glyphnames:						# as used by AGL Namer 1.0  (vintage 1999)			f.getlib('chars/' + `c.name` + '/AGLname')						# as used by some scripts at the FontBureau:			f.lib[key][c.name]		"""		self.log('making glyph rename table...')		source = None		for glyph in self.font:			options = []						# first, check the location preferred by the AGL Namer			if self.font.lib.has_key('chars'):				if self.font.lib['chars'].has_key(glyph.name):					x = self.font.lib['chars'][glyph.name]					if hasattr(x, 'keys'):						if x.has_key('AGLname'):							source = "defined in lib"							options.append(x['AGLname'])			# check the other location			x = self.font.getlib('chars/' + `glyph.name` + '/AGLname')			if x is not None:				options.append(x)						if self._renameDict is not None:				if self._renameDict.has_key(glyph.psname):					options.append(self._renameDict[glyph.psname])							if len(options) >= 1:				if len(options) > 1:					self.log("%d, %s has more than 1 alternative glyphname: %s"%(glyph.name, glyph.psname, `options`))				newGlyphName = filterIllegals(options[0])			else:				newGlyphName = glyph.psname			self._renameTable[glyph.psname] = newGlyphName		#print self._renameTable		for old, new in self._renameTable.items():			if old != new:				self.log("Renamed glyph %s -> %s, %s"%(old, new, source))		def _addReport(self, key, text):		self._fontLib[key] = text			def writeKerning(self):		"""Write the kerning.plist"""		self.log('writing kerning.plist...')		data = {}		for left, right in self.font.kerning.keys():			leftName = self._renameTable[self.font[left].psname]			rightName = self._renameTable[self.font[right].psname]			if not data.has_key(leftName):				data[leftName] = {}			data[leftName][rightName]= self.font.kerning[(left, right)]		path = os.path.join(self.dst, "kerning.plist")		writePlist(data, path)		def writeGlifs(self):		"""Write the glifs directory and contents.plist"""		print '	writing .glifs...'		glifDir = os.path.join(self.dst, "glyphs")		if not os.path.exists(glifDir):			os.makedirs(glifDir)		glyphsToDo = {}		for glyph in self.font:			if glyph is None: continue			glyphsToDo[glyph.psname] = glyph		glyphsToDo['.notdef'] = self.font[32]	# use space as .notdef		for glyphName, glyph in glyphsToDo.items():			glyphName = self._renameTable[glyph.psname]			if fogGlyphNameToUnicode.has_key(glyph.psname):				v = fogGlyphNameToUnicode[glyph.psname]				unicode = string.zfill(hex(v)[2:], 4)			else:				unicode = None			exportLib = {}			if glyph.lib:				exportLib = glyph.lib			if self._saveBackground:				bgGlyph = glyph.background				if len(bgGlyph)>0:					bgName = "#%s"%glyphName					exportLib["FogLayer_1"] = glyphName					exportLib["FogLayer_2"] = bgName					self._writeOneGlyph(bgGlyph, bgName, unicode, glifDir, glyph.width, exportLib=exportLib)			if len(glyph)>0:				self._writeOneGlyph(glyph, glyphName, unicode, glifDir, exportLib=exportLib)		contentsPath = os.path.join(self.dst, "glyphs", "contents.plist")		writePlist(self.contents,  contentsPath)	def _writeOneGlyph(self, glyph, glyphName, unicode, glifDir, width=None, exportLib={}):		if width is None:			width = glyph.width		if self._correctPath:			glyph.correctpath()		writer = FogGlifWriter(glifDir, glyphName, width, unicode, self.isQuadFont, self._interpretAnchors)		if exportLib:			ignore = []			if self._renameGlyphs:				# don't include the AGLname entry if it is used as real glyphname.				ignore.append('AGLname')			if self._flattenLib:				glyphLib = flattenLib(exportLib, FogUFOExportTag, ignore)			else:				glyphLib = filterLib(exportLib, ignore)			from StringIO import StringIO			f = StringIO()			writePlist(glyphLib, f, indentLevel=2, writeHeader=0)			plistLibHeader = string.rstrip(f.getvalue())			writer.addLib(plistLibHeader)		for item in glyph:			if item.type == item_open or item.type == item_closed:				isClosed = item.type == item_closed				writer.beginPath(isClosed)				for p in item:					smooth = p.type == pt_curve					writer.addPoint(p.bcpin, p.anchor, p.bcpout, smooth)				writer.endPath()			elif item.type == item_comp:				baseName = self.font[item.basechar].psname				writer.addComponent(baseName, item.offset)			else:				report.append("Glyph %s contains an unsupported item."%(glyph.psname))		self.contents[glyphName] = writer.save()		def writeFontInfo(self):		"""Write the fontinfo.plist"""		self.log('writing fontinfo.plist...')		data = {}		# XXXX more attributes to be added, perhaps also from font.lib? customise?		# XXXX use the right fog names for attributes		fontName = string.split(self.font.name, ".")[0]		familyName = string.split(fontName, '-')[0]		niceName = string.replace(fontName, '-', ' ')		data['ascender']= self.font.ascent		# check for positive descender values.		if self.font.descent >= 0:			desc = -self.font.descent		else:			desc = self.font.descent		data['descender']= desc		data['fullName']= fontName		data['menuName']= niceName		data['copyright'] = self.font.copyright		data['uniqueID'] = self.font.uniqueid		data['fondID'] = self.font.fondid		data['fondName'] = fontName		data['slantAngle'] = self.font.angle	# correct?		data['italicAngle'] = self.font.angle	# correct?		data['fontStyle'] = 64	# fontlab default		data['versionMajor'] = 1	# fontlab default		data['versionMinor'] = 0	# fontlab default		data['defaultWidth'] = 500	# robfog default		data['ttVendor'] = "RBFG"		data['unitsPerEm'] = self.font.em		path = os.path.join(self.dst, "fontinfo.plist")		writePlist(data, path)			def writeMetaInfo(self):		"""Write the metainfo.plist"""		self.log('writing metainfo.plist...')		data = {}		data['creator'] = "org.robofab.fogufoexport"		data['creatorVersion'] = __version__ 		data['formatVersion'] = 1		path = os.path.join(self.dst, "metainfo.plist")		writePlist(data, path)		def writeLib(self):		"""Write the lib.plist"""		data = {}		self.log('writing lib.plist...')		if self._flattenLib:			# ignore the 'chars' entry in font.lib, it contains the char.lib entries			data = flattenLib(self.font.lib, FogUFOExportTag, ignore=['chars'])		else:			data[FogUFOExportTag] = filterLib(self.font.lib, ignore=['chars'])		path = os.path.join(self.dst, "lib.plist")		writePlist(data, path)def flattenLib(lib, rootKey, ignore=[]):	"""Flatten the lib from a set of nested dicts to a flat dict with	keynames that are made up from the fog lib nested keys.		RoboFog-style lib entry: 		>> font.setlib("key/names/seperated/with/thingies", 100)		>> print font.lib		>> {"key":{"name":{"seperated":{"with":{"thingies":100}}}}}		RoboFab-style lib entry:		font.lib['key.names.seperated.by.thingies'] = 100		>> print font.lib['key.names.seperated.by.thingies']		>> 100		RoboFab prefers the flat dictionaries, but maybe there are	good reasons to store dicts the robofog way.	"""	flat = {}	if type(lib) is not DictType:		return lib	for key in lib.keys():		if key == "":			continue		if key in ignore:			continue		value = lib[key]		if type(value) == DictType:			for subKey, subValue in value.items():				item = flattenLib(subValue, rootKey+"."+key+"."+subKey)				if type(item) == DictType:					flat.update(item)				else:					flat[rootKey+"."+key+"."+subKey] = item		else:			flat[rootKey+"."+key] = value	return flat	def filterLib(lib, ignore=[]):	new = {}	for key, value in lib.items():		if key in ignore:			continue		if key == "":			continue		new[key] = value	return new