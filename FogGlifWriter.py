"""A glif writer for RoboFog glyphs to allow direct export of RoboFog material to RoboFab.HistoryApril 1, 2004 -- fixed closepath where one bcp would get added to a closing line"""__version__ = "1.1"import os, string, macfstry:	Falseexcept NameError:	False = 0	True = 1class FogGlifWriter:	"""This object can  write a glif file based on data it is fed. It does not use a pen model	as it does not exist in RobFog. Create a FogGlifWriter object, then iterate through the 	contours and points in the RoboFog glyph. Then call addPoint for each RoboFog point	(a bcp In, Anchor, bcp Out combo that is). Add composites by calling addComponent for	each of the components. Add the name, width and optional unicode value when you create	the writer.		It only supports bezier points.	Open path support untested.	Snippets of code are taken from robofab.gliflib.					"""		hdr = """<?xml version="1.0" encoding="macroman"?>"""	def __init__(self, rootDirectory, name, width, unicode=None, isQuadFont=0, interpretAnchors=False):		self._root = rootDirectory		self._contours = []		self._components = []		self._anchors = []		self._lib = None		self.data = []		self.name = name		self.width = width		self.isQuadFont = isQuadFont		self.unicode = unicode		self._curPath = []		self._prevBcpOut = None		self.glifExtension = "glif"		self._interpretAnchors = interpretAnchors		def addPoint(self, rbcpin, anchor, rbcpout, smooth=0,):		bcpin = rbcpin[0]+anchor[0], rbcpin[1]+anchor[1]		bcpout = rbcpout[0]+anchor[0], rbcpout[1]+anchor[1]		self._curPath.append((bcpin, anchor, bcpout, smooth))		def beginPath(self, openClosed):		self._curPath = [openClosed]			def endPath(self):		self._contours.append(self._curPath)		def addComponent(self, baseChar, offset=(0,0), scale=1):		self._components.append((baseChar, offset, scale))		def addLib(self, lib):		self._lib =  lib				def pointsToSegments(self, contour):		"""Convert to a list of segments"""		segments = []		#import PyBrowser		#PyBrowser.Browser(contour)		isClosed = contour[0]		contour = contour[1:]		firstBcpIn = contour[0][0]		prevBcpOut = contour[0][2]		lastBcpOut = contour[-1][2]		lastAnchor = contour[-1][0]		firstSmooth = contour[0][3]		prevAnchor = firstAnchor = contour[0][1]		if isClosed:			# enter the first point in the closed path manner			if firstBcpIn == firstAnchor and lastBcpOut == lastAnchor:				firstType = "line"			elif self.isQuadFont:				firstType = "qcurve"			else:				firstType = "curve"			segments.append((firstAnchor, firstType, firstSmooth))		else:			# enter the first point in the open path manner			# segments.append((firstBcpIn, None, None))			# any offcurve points before the first anchor in an open path are lost			segments.append((firstAnchor, "move", None))		for bcpIn, anchor, bcpOut, smooth in contour[1:]:			if prevBcpOut <> prevAnchor or bcpIn <> anchor:				# it's a curve				segments.append((prevBcpOut, None, 0))				segments.append((bcpIn, None, 0))				if self.isQuadFont:					segments.append((anchor, 'qcurve', smooth))				else:					segments.append((anchor, 'curve', smooth))			else:				# it's a line				segments.append((anchor, 'line', 0))			prevBcpOut = bcpOut			prevAnchor = anchor		if isClosed:			# close the path in the closed path manner			#			#	segments.append((prevBcpOut, None, 0))			#	was done here, but this seems  to cause			#	problems for some of Cyrus' exports.			#	both straight lined and curved exports			#	work better with the segment moved			#			if firstType == 'curve' or firstType == 'qcurve':				segments.append((prevBcpOut, None, 0))	# moved here.				segments.append((firstBcpIn, None, 0))		else:			# close the path in the open path manner			segments.append((prevBcpOut, None, 0))		return segments		def save(self):		fileName = self.glyphNameToFileName(self.name)		path = os.path.join(self._root, fileName)		f = open(path, 'w')		f.write(self.write())		f.close		fs = macfs.FSSpec(path)		fs.SetCreatorType('R*ch', 'TEXT')		return fileName		def glyphNameToFileName(self, glyphName):		"""Convert a glyph name to a file name, for example:			'a'     -> 'a.glif'			'A'     -> 'A_.glif'			'A.alt' -> 'A_.alt.glif'		"""		parts = string.split(glyphName, ".")		if parts[0] != string.lower(parts[0]):			parts[0] = parts[0] + "_"		baseName = string.join(parts, '.')		maxLen = 28		if len(baseName)+len(self.glifExtension) > maxLen:			baseName = baseName[:maxLen-(len(self.glifExtension)+len(self.unicode)+1)]+"_"+self.unicode		if self.glifExtension:			baseName = baseName + "." + self.glifExtension		return baseName	def write(self):		"""Write the glif XML."""		self.data.append(self.hdr)		self.data.append('<glyph name="%s" format="1">'%self.name)				self.data.append('\t<advance width="%d"/>'%self.width)		if self.unicode is not None:			self.data.append('\t<unicode hex="%s"/>'%self.unicode)		if self._lib <> None:			self.data.append('\t<lib>')			self.data.append(self._lib)			self.data.append('\t</lib>')		self.data.append('\t<outline>')			if self._contours:			for contour in self._contours:				if len(contour) == 2 and self._interpretAnchors and self.name!="space":					# assume it's an anchor and it has been taken care of already					#    <contour>					#      <point x="301" y="681" type="move" name="top"/>					#    </contour>					name = "anchor"					self.data.append('\t\t<contour>')								self.data.append('\t\t\t<point x="%d" y="%d" type="move" name="%s"/>'%(point[0], point[1], name))					self.data.append('\t\t</contour>')								continue				points = self.pointsToSegments(contour)				self.data.append('\t\t<contour>')							for (point, type, smooth) in points:					if type is not None:						if smooth:							self.data.append('\t\t\t<point x="%d" y="%d" type="%s" smooth="yes"/>'%(point[0], point[1], type))						else:							self.data.append('\t\t\t<point x="%d" y="%d" type="%s"/>'%(point[0], point[1], type))					else:						self.data.append('\t\t\t<point x="%d" y="%d"/>'%(point[0], point[1]))				self.data.append('\t\t</contour>')		if self._components:			for (base, offset, scale) in self._components:				if offset:					self.data.append('\t\t<component base="%s" xOffset="%d" yOffset="%d"/>'%(base, offset[0], offset[1]))				else:					self.data.append('\t\t<component base="%s"/>'%(base, offset[0], offset[1]))		self.data.append('\t</outline>')					self.data.append('</glyph>')					return string.join(self.data, '\r')