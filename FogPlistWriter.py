"""This implements the PlistLib Writer for python < 2.2.Deconstructed from Just van Rossums's plistlib.py (I apoligise!),but without the 2.3 python dependencies, so it can be used in elderlyprograms with elderly embedded pythons. This produces a plist filewith macroman encoding as the whole unicode schtick doesn't exist in1.5.2.For comments and notes on how to use this module, please have a lookat the original plistlib.py.Supported:	string	integer	dictionary	list	tuple	Not supported:	binary data, uses base64 which might be available,		I'll add it when I need it.	dates: uses xml.utils.iso8601		I'll add it when I need it."""import stringimport sysfrom types import StringType, IntType, FloatType, ListType, TupleType, DictTypeFogPlistWriterError = "FogPlistWriterError"PLISTHEADER = """\<?xml version="1.0" encoding="macroman"?><!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">"""# cruft to support booleans in Python <= 2.3# uh, well, 2.2 <= Python <= 2.3# as this solution uses new style classes which are new in 2.2# it doesn't solve anything < 2.2# so here's another bool implementation.# Not sure if it is needed, but it works.class bool:	def __init__(self, value):		self._value = self._evaluate(value)		def _evaluate(self, value):		return not not value			def __eq__(self, value):		if self._evaluate(value) == self._value:			return 1		return 0			def __repr__(self):		if self._value:			return "True"		else:			return "False"		__str__ = __repr__True = bool(1)False = bool(0)class DumbXMLWriter:	"""A Simple Plist writer for python 1.5"""	def __init__(self, file, indentLevel=0, indent="\t"):		self.file = file		self.stack = []		self.indentLevel = indentLevel		self.indent = indent	def beginElement(self, element):		self.stack.append(element)		self.writeln("<%s>" % element)		self.indentLevel = self.indentLevel + 1	def endElement(self, element):		if self.indentLevel < 1:			raise FogPlistWriterError, "Indentation problem"		if self.stack.pop() <> element:			raise FogPlistWriterError, "Some other problem"		self.indentLevel = self.indentLevel - 1		self.writeln("</%s>" % element)	def simpleElement(self, element, value=None):		if value is not None:			value = _escapeAndEncode(value)			self.writeln("<%s>%s</%s>" % (element, value, element))		else:			self.writeln("<%s/>" % element)	def writeln(self, line):		if line:			self.file.write(self.indentLevel * self.indent + line + "\n")		else:			self.file.write("\n")def _escapeAndEncode(text):	_controls = """\x00\x01\x02\x03\x04\x05\x06\x07\x08\x0b\x0e\x0f"	"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"""	text = string.replace(text, "\r\n", "\n")	# convert DOS line endings	text = string.replace(text, "\r", "\n")	# convert Mac line endings	text = string.replace(text, "&", "&amp;")	# escape '&'	text = string.replace(text, "<", "&lt;")	# escape '<'	filtered = ""	for c in text:		if c in _controls:			c = "?"		filtered = filtered + c	return filteredclass PlistWriter(DumbXMLWriter):	def __init__(self, file, indentLevel=0, indent="\t", writeHeader=1):		if writeHeader:			file.write(PLISTHEADER)		DumbXMLWriter.__init__(self, file, indentLevel, indent)	def writeValue(self, value):		if isinstance(value, StringType):	# no unicode			self.simpleElement("string", value)		elif isinstance(value, bool):			# must switch for bool before int, as bool is a			# subclass of int...			if value:				self.simpleElement("true")			else:				self.simpleElement("false")		elif isinstance(value, IntType):			self.simpleElement("integer", str(value))		elif isinstance(value, FloatType):			# should perhaps use repr() for better precision?			self.simpleElement("real", str(value))		elif isinstance(value, DictType):			self.writeDict(value)		#elif isinstance(value, Data):		#	self.writeData(value)		#elif isinstance(value, Date):		#	self.simpleElement("date", value.toString())		elif isinstance(value, TupleType) or isinstance(value, ListType):			self.writeArray(value)		else:			raise TypeError("unsuported type: %s" % type(value))	def writeData(self, data):		self.beginElement("data")		for line in data.asBase64().split("\n"):			if line:				self.writeln(line)		self.endElement("data")	def writeDict(self, d):		self.beginElement("dict")		items = d.items()		items.sort()		for key, value in items:			if not isinstance(key, StringType):				raise TypeError("keys must be strings")			self.simpleElement("key", key)			self.writeValue(value)		self.endElement("dict")	def writeArray(self, array):		self.beginElement("array")		for value in array:			self.writeValue(value)		self.endElement("array")def writePlist(rootObject, pathOrFile, indentLevel=1, writeHeader=1):	"""Write 'rootObject' to a .plist file. 'pathOrFile' may either be a	file name or a (writable) file object.	"""	didOpen = 0	if isinstance(pathOrFile, StringType):		pathOrFile = open(pathOrFile, "w")		didOpen = 1	writer = PlistWriter(pathOrFile, indentLevel=indentLevel, writeHeader=writeHeader)	if writeHeader:		writer.writeln("<plist version=\"1.0\">")	writer.writeValue(rootObject)	if writeHeader:		writer.writeln("</plist>")	if didOpen:		pathOrFile.close()if __name__ == "__main__":	from StringIO import StringIO	f = StringIO()	a = {"aaa":[1, 2, 3.142], "b": {"a":100, 'c':True, "controls":"\x00\x01\x02\x03", 'b':(1, {"hello":[1, 2, 3]}, 3)}}	p = writePlist(a, f)	print f.getvalue()	f.seek(0)	from robofab.plistlib import readPlist	p = readPlist(f)	print "contents of plist:", p	print "interpreted with real plistlib:", a